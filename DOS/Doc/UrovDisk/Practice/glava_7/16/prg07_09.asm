;----------------------------------------------------------
;prg07_09.asm - программа заполнения файла my_file.txt данными в виде строк символов, вводимыми с клавиатуры.
;----------------------------------------------------------
masm
model small
buf_0ah	struc
len_buf	db	83	;длина buf_0ah
len_in	db	0	;действительная длина введенного слова (без учета 0dh)
buf_in	db	82 dup (20h)	;буфер для ввода (с учетом 0dh и позднее добавляем 0ah)
ends
.data
handle	dw	0	;дескриптор файла
filename	db	'my_file.txt',0
point_fname	dd	filename
buf	buf_0ah	<>
prev_d	label	dword	;для сохранения длины предыдущей строки при выводе с конца файла
prev	dw	0
	dw	0
middle	dd	0	;позиция в середине файла, при достижении которой снизу выходим из программы
.stack	256
.486
.code
main:
	mov	ax,@data	;адрес сегмента данных в регистр ax
	mov	ds,ax	;ax в ds
;------открываем файл-----------------------------------------------
	xor	cx,cx	;атрибуты файла - обычный файл
	mov	bx,2	;режим доступа - доступ для чтения-записи, режим буферизации MS DOS
	mov	dx,12h	;если файл существует, то открыть его без сохранения прежнего содержимого, в обратном случае создать его
	lds	si,point_fname	;формируем указатель на имя файла
	mov	ah,6ch	;номер функции DOS
	int	21h	;открываем (создаем) файл
	jc	exit	;если ошибка, то переход на конец
;-------------------------------------------------------------------
;действия при успешном открытии файла:
	mov	handle,ax	;сохраним дескриптор файла
;----позиционируем файловый указатель с начала файла----------------
	mov	ah,42h
	xor	al,al
	xor	cx,cx
	xor	dx,dx
	mov	bx,handle
	int	21h
;-------------------------------------------------------------------
cycl:
;вводим очередную строку с клавиатуры
	lea	dx,buf
	mov	ah,0ah
	int	21h
;для красоты ввода выводим на экран символ 0ah
	mov	dl,0ah
	mov	ah,2
	int	21h
	cmp	buf.buf_in,20h	;первый символ введенной строки сравниваем с пробелом
	je	revers	;переход на изменение ввода - 
;добавляем 0ah в конец введенной строки
	lea	si,buf.buf_in
	mov	al,buf.len_in
	cbw
push	si
	add	si,ax
	inc	si	;учитываем неучтенный в len_in символ 0dh
	mov	byte ptr [si],0ah
;--------вывод в файл:---------------------------------------------
pop	dx	;указатель на область откуда будем выводить строку
	mov	bx,handle
	add	ax,2	;учитываем неучтенный в len_in символ 0dh
	mov	cx,ax	;длина выводимых данных
	mov	ah,40h
	int	21h
;-------------------------------------------------------------------
	jmp	cycl
revers:
;записываем файл с конца, предварительно расширив его
;узнаем сколько было уже записано до этого:
;для этого вначале сбрасываем буферы на диск
	mov	bx,handle
	mov	ah,68h
	int	21h
;теперь можно и узнать:
;------определение длины файла--------------------------------------
	mov	al,2
	xor	cx,cx
	xor	dx,dx	;CX:DX =0 - нулевое смещение
	mov	ah,42h
	int	21h	;в DX:AX возвращается длина файла в байтах
	jc	exit	;если ошибка
;-------------------------------------------------------------------
;формируем полную длину в edx
	shl	eax,16
	shld	edx,eax,16
	mov	middle,edx	;сохраним как условие выхода из программы при достижении снизу
;-------расширение файла с помощью функции 42h int 21h и последующей записи-----
;умножаем длину на 2, при первой операции записи файл расширится:
	shl	edx,1
	shld	ecx,edx,16
	mov	al,0
	xor	cx,cx
	mov	ah,42h
	int	21h	;расширяем файл, устанавливая указатель
	jc	exit	;если ошибка
;расширим файл, выведя последнюю введенную строку с пробелом:
;-------------------------------------------------------------------------------
cycl2:
	lea	si,buf.buf_in
	mov	al,buf.len_in
	cbw
push	si
	add	si,ax
	inc	si	;учитываем неучтенный в len_in символ 0dh
;добавляем 0ah в конец введенной строки
	mov	byte ptr [si],0ah
;выводим в файл:
pop	dx	;указатель на область откуда будем выводить строку
	add	ax,2	;учитываем неучтенный в len_in символ 0dh
	mov	cx,ax	;длина выводимых данных
	mov	prev,ax	;сохраним длину для корректировки при выводе следующей строки
	mov	bx,handle
	mov	ah,40h
	int	21h
	jc	exit
;сбрасываем буфер, чтобы смотреть изменения в файле при работе в отладчике - легче запретить (см. обсуждение ниже)
	mov	bx,handle
	mov	ah,68h
	int	21h
;вводим очередную строку с клавиатуры
	lea	dx,buf
	mov	ah,0ah
	int	21h
;для красоты ввода выводим на экран символ 0ah
	mov	dl,0ah
	mov	ah,2
	int	21h
;------использование 42h с отрицательным смещением относительно текущего значения файлового указателя:
;устанавливаем файловый указатель в позицию вывода следующей строки с учетом того, что выводим с конца (текущей позиции) файла:
	xor	ecx,ecx
	mov	al,buf.len_in
	cbw
	add	prev,ax
	add	prev,2	;учитываем наличие 0d0ah
	sub	ecx,prev_d	;получаем отрицательное смещение - сформируем его в паре CX:DX
	shrd	edx,ecx,16
	shr	edx,16	;довернем edx
	shr	ecx,16	;и ecx
;устанавливаем файловую позицию для записи очередной строки
	mov	bx,handle
	mov	ah,42h
	mov	al,1	;смещение от текущей позиции
	int	21h
;------------------------------------------------------------------------
;сравним текущую позицию с middle
	shl	eax,16
	shld	edx,eax,16
	cmp	edx,middle
	jl	exit
	jmp	cycl2
exit:
;выход из программы
	mov	ax,4c00h	;пересылка 4c00h в регистр ax
	int	21h	;вызов прерывания с номером 21h
end	main		;конец программы с точкой входа main
