add_bcd	macro	summand_1,len_1,summand_2,len_2,sum
local	m1,m2,m3
;----------------------------------------------------------
;add_bcd summand_1,len_1,summand_2,len_2,sum - макрокоманда
;сложения неупакованных BCD-чисел размером len_1 и len_2 
;байт и помещение результата в sum.
;Вход: summand_1 и summand_2 - адреса младших байт 
;слагаемых; len_1 и len_2 - длины слагаемых в байтах.
;Выход: sum - адрес младшего байта поля суммы. Желательно, 
;чтобы это поле имело длину на единицу больше, чем длина 
;самого длинного слагаемого.
;Порядок следования байт - младший байт по младшему адресу (Intel).
;----------------------------------------------------------
	push	si
	push	bx
	mov	ax,len_1
	cmp	ax,len_2
	jna	m2
	mov	cx,len_1	;длина большего для сложения (см. ниже)
	push	cx
	mov	cx,len_2	;длина меньшего для сложения (см. ниже)
	push	cx
	mov	cx,ax
	lea	bx,summand_1	;адрес большего источника для сложения
	lea	si,summand_2	;адрес меньшего источника для movsb
	jmp	m3
m2:
	mov	cx,len_2	;длина большего для сложения (см. ниже)
	push	cx
	mov	cx,len_1	;длина меньшего для сложения (см. ниже)
	push	cx
	mov	cx,len_2
	lea	bx,summand_2	;адрес большего источника для сложения
	lea	si,summand_1	;адрес меньшего источника для movsb
m3:
;заполняем sum нулями - длина определена выше:
	cld
	xor	al,al
	lea	di, sum
rep	stosb
;пересылка меньшего (по длине) BCD-числа в sum:
	cld
	push	ds
	pop	es
;адрес источника см. выше
	lea	di, sum
	pop	cx	;длина была определена выше и соотв. меньшему BCD-числу
rep	movsb
	pop	cx	;цикл по большему
	xor	si,si
m1:	mov	al,[bx][si]
	adc	al, sum[si]
	aaa
	mov	sum[si],al
	inc	si
	loop	m1
	adc	sum[si],0
	pop	bx
	pop	si
	endm
